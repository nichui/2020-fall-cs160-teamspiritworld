{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport toChildrenArray from \"rc-util/es/Children/toArray\";\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from './FieldContext';\nimport { toArray } from './utils/typeUtil';\nimport { validateRules } from './utils/validateUtil';\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from './utils/valueUtil';\n\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n\n  return prevValue !== nextValue;\n} // We use Class instead of Hooks here since it will cost much code by using Hooks.\n\n\nvar Field = /*#__PURE__*/function (_React$Component) {\n  _inherits(Field, _React$Component);\n\n  var _super = _createSuper(Field); // ============================== Subscriptions ==============================\n\n\n  function Field(props) {\n    var _this;\n\n    _classCallCheck(this, Field);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      resetCount: 0\n    };\n    _this.cancelRegisterFunc = null;\n    _this.mounted = false;\n    /**\n     * Follow state should not management in State since it will async update by React.\n     * This makes first render of form can not get correct state value.\n     */\n\n    _this.touched = false;\n    /** Mark when touched & validated. Currently only used for `dependencies` */\n\n    _this.dirty = false;\n    _this.validatePromise = null;\n    _this.errors = [];\n\n    _this.cancelRegister = function () {\n      var _this$props = _this.props,\n          preserve = _this$props.preserve,\n          isListField = _this$props.isListField;\n\n      if (_this.cancelRegisterFunc) {\n        _this.cancelRegisterFunc(isListField, preserve);\n      }\n\n      _this.cancelRegisterFunc = null;\n    }; // ================================== Utils ==================================\n\n\n    _this.getNamePath = function () {\n      var _this$props2 = _this.props,\n          name = _this$props2.name,\n          fieldContext = _this$props2.fieldContext;\n      var _fieldContext$prefixN = fieldContext.prefixName,\n          prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;\n      return name !== undefined ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];\n    };\n\n    _this.getRules = function () {\n      var _this$props3 = _this.props,\n          _this$props3$rules = _this$props3.rules,\n          rules = _this$props3$rules === void 0 ? [] : _this$props3$rules,\n          fieldContext = _this$props3.fieldContext;\n      return rules.map(function (rule) {\n        if (typeof rule === 'function') {\n          return rule(fieldContext);\n        }\n\n        return rule;\n      });\n    };\n\n    _this.refresh = function () {\n      if (!_this.mounted) return;\n      /**\n       * Clean up current node.\n       */\n\n      _this.setState(function (_ref) {\n        var resetCount = _ref.resetCount;\n        return {\n          resetCount: resetCount + 1\n        };\n      });\n    }; // ========================= Field Entity Interfaces =========================\n    // Trigger by store update. Check if need update the component\n\n\n    _this.onStoreChange = function (prevStore, namePathList, info) {\n      var _this$props4 = _this.props,\n          shouldUpdate = _this$props4.shouldUpdate,\n          _this$props4$dependen = _this$props4.dependencies,\n          dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen,\n          onReset = _this$props4.onReset;\n      var store = info.store;\n\n      var namePath = _this.getNamePath();\n\n      var prevValue = _this.getValue(prevStore);\n\n      var curValue = _this.getValue(store);\n\n      var namePathMatch = namePathList && containsNamePath(namePathList, namePath); // `setFieldsValue` is a quick access to update related status\n\n      if (info.type === 'valueUpdate' && info.source === 'external' && prevValue !== curValue) {\n        _this.touched = true;\n        _this.dirty = true;\n        _this.validatePromise = null;\n        _this.errors = [];\n      }\n\n      switch (info.type) {\n        case 'reset':\n          if (!namePathList || namePathMatch) {\n            // Clean up state\n            _this.touched = false;\n            _this.dirty = false;\n            _this.validatePromise = null;\n            _this.errors = [];\n\n            if (onReset) {\n              onReset();\n            }\n\n            _this.refresh();\n\n            return;\n          }\n\n          break;\n\n        case 'setField':\n          {\n            if (namePathMatch) {\n              var data = info.data;\n\n              if ('touched' in data) {\n                _this.touched = data.touched;\n              }\n\n              if ('validating' in data && !('originRCField' in data)) {\n                _this.validatePromise = data.validating ? Promise.resolve([]) : null;\n              }\n\n              if ('errors' in data) {\n                _this.errors = data.errors || [];\n              }\n\n              _this.dirty = true;\n\n              _this.reRender();\n\n              return;\n            } // Handle update by `setField` with `shouldUpdate`\n\n\n            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n              _this.reRender();\n\n              return;\n            }\n\n            break;\n          }\n\n        case 'dependenciesUpdate':\n          {\n            /**\n             * Trigger when marked `dependencies` updated. Related fields will all update\n             */\n            var dependencyList = dependencies.map(getNamePath); // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n            // emitted earlier and they will work there\n            // If set it may cause unnecessary twice rerendering\n\n            if (dependencyList.some(function (dependency) {\n              return containsNamePath(info.relatedFields, dependency);\n            })) {\n              _this.reRender();\n\n              return;\n            }\n\n            break;\n          }\n\n        default:\n          // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n          //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n          //      If `namePathList` is [['list']] (List value update), Field should be updated\n          //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n          // 2.\n          //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n          //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n          //       is not provided\n          //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n          //       else to check if value changed\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            _this.reRender();\n\n            return;\n          }\n\n          break;\n      }\n\n      if (shouldUpdate === true) {\n        _this.reRender();\n      }\n    };\n\n    _this.validateRules = function (options) {\n      var _this$props5 = _this.props,\n          _this$props5$validate = _this$props5.validateFirst,\n          validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate,\n          messageVariables = _this$props5.messageVariables;\n\n      var _ref2 = options || {},\n          triggerName = _ref2.triggerName;\n\n      var namePath = _this.getNamePath();\n\n      var filteredRules = _this.getRules();\n\n      if (triggerName) {\n        filteredRules = filteredRules.filter(function (rule) {\n          var validateTrigger = rule.validateTrigger;\n\n          if (!validateTrigger) {\n            return true;\n          }\n\n          var triggerList = toArray(validateTrigger);\n          return triggerList.includes(triggerName);\n        });\n      }\n\n      var promise = validateRules(namePath, _this.getValue(), filteredRules, options, validateFirst, messageVariables);\n      _this.dirty = true;\n      _this.validatePromise = promise;\n      _this.errors = []; // Force trigger re-render since we need sync renderProps with new meta\n\n      _this.reRender();\n\n      promise.catch(function (e) {\n        return e;\n      }).then(function () {\n        var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        if (_this.validatePromise === promise) {\n          _this.validatePromise = null;\n          _this.errors = errors;\n\n          _this.reRender();\n        }\n      });\n      return promise;\n    };\n\n    _this.isFieldValidating = function () {\n      return !!_this.validatePromise;\n    };\n\n    _this.isFieldTouched = function () {\n      return _this.touched;\n    };\n\n    _this.isFieldDirty = function () {\n      return _this.dirty;\n    };\n\n    _this.getErrors = function () {\n      return _this.errors;\n    };\n\n    _this.isListField = function () {\n      return _this.props.isListField;\n    }; // ============================= Child Component =============================\n\n\n    _this.getMeta = function () {\n      // Make error & validating in cache to save perf\n      _this.prevValidating = _this.isFieldValidating();\n      var meta = {\n        touched: _this.isFieldTouched(),\n        validating: _this.prevValidating,\n        errors: _this.errors,\n        name: _this.getNamePath()\n      };\n      return meta;\n    }; // Only return validate child node. If invalidate, will do nothing about field.\n\n\n    _this.getOnlyChild = function (children) {\n      // Support render props\n      if (typeof children === 'function') {\n        var meta = _this.getMeta();\n\n        return _objectSpread(_objectSpread({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {\n          isFunction: true\n        });\n      } // Filed element only\n\n\n      var childList = toChildrenArray(children);\n\n      if (childList.length !== 1 || !React.isValidElement(childList[0])) {\n        return {\n          child: childList,\n          isFunction: false\n        };\n      }\n\n      return {\n        child: childList[0],\n        isFunction: false\n      };\n    }; // ============================== Field Control ==============================\n\n\n    _this.getValue = function (store) {\n      var getFieldsValue = _this.props.fieldContext.getFieldsValue;\n\n      var namePath = _this.getNamePath();\n\n      return getValue(store || getFieldsValue(true), namePath);\n    };\n\n    _this.getControlled = function () {\n      var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$props6 = _this.props,\n          trigger = _this$props6.trigger,\n          validateTrigger = _this$props6.validateTrigger,\n          getValueFromEvent = _this$props6.getValueFromEvent,\n          normalize = _this$props6.normalize,\n          valuePropName = _this$props6.valuePropName,\n          getValueProps = _this$props6.getValueProps,\n          fieldContext = _this$props6.fieldContext;\n      var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n\n      var namePath = _this.getNamePath();\n\n      var getInternalHooks = fieldContext.getInternalHooks,\n          getFieldsValue = fieldContext.getFieldsValue;\n\n      var _getInternalHooks = getInternalHooks(HOOK_MARK),\n          dispatch = _getInternalHooks.dispatch;\n\n      var value = _this.getValue();\n\n      var mergedGetValueProps = getValueProps || function (val) {\n        return _defineProperty({}, valuePropName, val);\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      var originTriggerFunc = childProps[trigger];\n\n      var control = _objectSpread(_objectSpread({}, childProps), mergedGetValueProps(value)); // Add trigger\n\n\n      control[trigger] = function () {\n        // Mark as touched\n        _this.touched = true;\n        _this.dirty = true;\n        var newValue;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (getValueFromEvent) {\n          newValue = getValueFromEvent.apply(void 0, args);\n        } else {\n          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));\n        }\n\n        if (normalize) {\n          newValue = normalize(newValue, value, getFieldsValue(true));\n        }\n\n        dispatch({\n          type: 'updateValue',\n          namePath: namePath,\n          value: newValue\n        });\n\n        if (originTriggerFunc) {\n          originTriggerFunc.apply(void 0, args);\n        }\n      }; // Add validateTrigger\n\n\n      var validateTriggerList = toArray(mergedValidateTrigger || []);\n      validateTriggerList.forEach(function (triggerName) {\n        // Wrap additional function of component, so that we can get latest value from store\n        var originTrigger = control[triggerName];\n\n        control[triggerName] = function () {\n          if (originTrigger) {\n            originTrigger.apply(void 0, arguments);\n          } // Always use latest rules\n\n\n          var rules = _this.props.rules;\n\n          if (rules && rules.length) {\n            // We dispatch validate to root,\n            // since it will update related data with other field with same name\n            dispatch({\n              type: 'validateField',\n              namePath: namePath,\n              triggerName: triggerName\n            });\n          }\n        };\n      });\n      return control;\n    }; // Register on init\n\n\n    if (props.fieldContext) {\n      var getInternalHooks = props.fieldContext.getInternalHooks;\n\n      var _getInternalHooks2 = getInternalHooks(HOOK_MARK),\n          registerField = _getInternalHooks2.registerField;\n\n      _this.cancelRegisterFunc = registerField(_assertThisInitialized(_this));\n    }\n\n    return _this;\n  }\n\n  _createClass(Field, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var shouldUpdate = this.props.shouldUpdate;\n      this.mounted = true; // One more render for component in case fields not ready\n\n      if (shouldUpdate === true) {\n        this.reRender();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelRegister();\n      this.mounted = false;\n    }\n  }, {\n    key: \"reRender\",\n    value: function reRender() {\n      if (!this.mounted) return;\n      this.forceUpdate();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var resetCount = this.state.resetCount;\n      var children = this.props.children;\n\n      var _this$getOnlyChild = this.getOnlyChild(children),\n          child = _this$getOnlyChild.child,\n          isFunction = _this$getOnlyChild.isFunction; // Not need to `cloneElement` since user can handle this in render function self\n\n\n      var returnChildNode;\n\n      if (isFunction) {\n        returnChildNode = child;\n      } else if (React.isValidElement(child)) {\n        returnChildNode = React.cloneElement(child, this.getControlled(child.props));\n      } else {\n        warning(!child, '`children` of Field is not validate ReactElement.');\n        returnChildNode = child;\n      }\n\n      return React.createElement(React.Fragment, {\n        key: resetCount\n      }, returnChildNode);\n    }\n  }]);\n\n  return Field;\n}(React.Component);\n\nField.contextType = FieldContext;\nField.defaultProps = {\n  trigger: 'onChange',\n  valuePropName: 'value'\n};\n\nfunction WrapperField(_ref4) {\n  var name = _ref4.name,\n      restProps = _objectWithoutProperties(_ref4, [\"name\"]);\n\n  var fieldContext = React.useContext(FieldContext);\n  var namePath = name !== undefined ? getNamePath(name) : undefined;\n  var key = 'keep';\n\n  if (!restProps.isListField) {\n    key = \"_\".concat((namePath || []).join('_'));\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    warning(restProps.preserve !== false || !restProps.isListField, '`preserve` should not apply on Form.List fields.');\n  }\n\n  return React.createElement(Field, Object.assign({\n    key: key,\n    name: namePath\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\n\nexport default WrapperField;","map":{"version":3,"sources":["C:/Users/khatk/Desktop/Tutorials/Web Development/spiritworld/client/node_modules/rc-field-form/es/Field.js"],"names":["_objectWithoutProperties","_defineProperty","_objectSpread","_toConsumableArray","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_createSuper","toChildrenArray","warning","React","FieldContext","HOOK_MARK","toArray","validateRules","containsNamePath","defaultGetValueFromEvent","getNamePath","getValue","requireUpdate","shouldUpdate","prev","next","prevValue","nextValue","info","source","Field","_React$Component","_super","props","_this","call","state","resetCount","cancelRegisterFunc","mounted","touched","dirty","validatePromise","errors","cancelRegister","_this$props","preserve","isListField","_this$props2","name","fieldContext","_fieldContext$prefixN","prefixName","undefined","concat","getRules","_this$props3","_this$props3$rules","rules","map","rule","refresh","setState","_ref","onStoreChange","prevStore","namePathList","_this$props4","_this$props4$dependen","dependencies","onReset","store","namePath","curValue","namePathMatch","type","data","validating","Promise","resolve","reRender","length","dependencyList","some","dependency","relatedFields","options","_this$props5","_this$props5$validate","validateFirst","messageVariables","_ref2","triggerName","filteredRules","filter","validateTrigger","triggerList","includes","promise","catch","e","then","arguments","isFieldValidating","isFieldTouched","isFieldDirty","getErrors","getMeta","prevValidating","meta","getOnlyChild","children","getControlled","isFunction","childList","isValidElement","child","getFieldsValue","childProps","_this$props6","trigger","getValueFromEvent","normalize","valuePropName","getValueProps","mergedValidateTrigger","getInternalHooks","_getInternalHooks","dispatch","value","mergedGetValueProps","val","originTriggerFunc","control","newValue","_len","args","Array","_key","apply","validateTriggerList","forEach","originTrigger","_getInternalHooks2","registerField","key","componentDidMount","componentWillUnmount","forceUpdate","render","_this$getOnlyChild","returnChildNode","cloneElement","createElement","Fragment","Component","contextType","defaultProps","WrapperField","_ref4","restProps","useContext","join","process","env","NODE_ENV","Object","assign"],"mappings":"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","sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport toChildrenArray from \"rc-util/es/Children/toArray\";\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from './FieldContext';\nimport { toArray } from './utils/typeUtil';\nimport { validateRules } from './utils/validateUtil';\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from './utils/valueUtil';\n\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n\n  return prevValue !== nextValue;\n} // We use Class instead of Hooks here since it will cost much code by using Hooks.\n\n\nvar Field = /*#__PURE__*/function (_React$Component) {\n  _inherits(Field, _React$Component);\n\n  var _super = _createSuper(Field);\n\n  // ============================== Subscriptions ==============================\n  function Field(props) {\n    var _this;\n\n    _classCallCheck(this, Field);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      resetCount: 0\n    };\n    _this.cancelRegisterFunc = null;\n    _this.mounted = false;\n    /**\n     * Follow state should not management in State since it will async update by React.\n     * This makes first render of form can not get correct state value.\n     */\n\n    _this.touched = false;\n    /** Mark when touched & validated. Currently only used for `dependencies` */\n\n    _this.dirty = false;\n    _this.validatePromise = null;\n    _this.errors = [];\n\n    _this.cancelRegister = function () {\n      var _this$props = _this.props,\n          preserve = _this$props.preserve,\n          isListField = _this$props.isListField;\n\n      if (_this.cancelRegisterFunc) {\n        _this.cancelRegisterFunc(isListField, preserve);\n      }\n\n      _this.cancelRegisterFunc = null;\n    }; // ================================== Utils ==================================\n\n\n    _this.getNamePath = function () {\n      var _this$props2 = _this.props,\n          name = _this$props2.name,\n          fieldContext = _this$props2.fieldContext;\n      var _fieldContext$prefixN = fieldContext.prefixName,\n          prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;\n      return name !== undefined ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];\n    };\n\n    _this.getRules = function () {\n      var _this$props3 = _this.props,\n          _this$props3$rules = _this$props3.rules,\n          rules = _this$props3$rules === void 0 ? [] : _this$props3$rules,\n          fieldContext = _this$props3.fieldContext;\n      return rules.map(function (rule) {\n        if (typeof rule === 'function') {\n          return rule(fieldContext);\n        }\n\n        return rule;\n      });\n    };\n\n    _this.refresh = function () {\n      if (!_this.mounted) return;\n      /**\n       * Clean up current node.\n       */\n\n      _this.setState(function (_ref) {\n        var resetCount = _ref.resetCount;\n        return {\n          resetCount: resetCount + 1\n        };\n      });\n    }; // ========================= Field Entity Interfaces =========================\n    // Trigger by store update. Check if need update the component\n\n\n    _this.onStoreChange = function (prevStore, namePathList, info) {\n      var _this$props4 = _this.props,\n          shouldUpdate = _this$props4.shouldUpdate,\n          _this$props4$dependen = _this$props4.dependencies,\n          dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen,\n          onReset = _this$props4.onReset;\n      var store = info.store;\n\n      var namePath = _this.getNamePath();\n\n      var prevValue = _this.getValue(prevStore);\n\n      var curValue = _this.getValue(store);\n\n      var namePathMatch = namePathList && containsNamePath(namePathList, namePath); // `setFieldsValue` is a quick access to update related status\n\n      if (info.type === 'valueUpdate' && info.source === 'external' && prevValue !== curValue) {\n        _this.touched = true;\n        _this.dirty = true;\n        _this.validatePromise = null;\n        _this.errors = [];\n      }\n\n      switch (info.type) {\n        case 'reset':\n          if (!namePathList || namePathMatch) {\n            // Clean up state\n            _this.touched = false;\n            _this.dirty = false;\n            _this.validatePromise = null;\n            _this.errors = [];\n\n            if (onReset) {\n              onReset();\n            }\n\n            _this.refresh();\n\n            return;\n          }\n\n          break;\n\n        case 'setField':\n          {\n            if (namePathMatch) {\n              var data = info.data;\n\n              if ('touched' in data) {\n                _this.touched = data.touched;\n              }\n\n              if ('validating' in data && !('originRCField' in data)) {\n                _this.validatePromise = data.validating ? Promise.resolve([]) : null;\n              }\n\n              if ('errors' in data) {\n                _this.errors = data.errors || [];\n              }\n\n              _this.dirty = true;\n\n              _this.reRender();\n\n              return;\n            } // Handle update by `setField` with `shouldUpdate`\n\n\n            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n              _this.reRender();\n\n              return;\n            }\n\n            break;\n          }\n\n        case 'dependenciesUpdate':\n          {\n            /**\n             * Trigger when marked `dependencies` updated. Related fields will all update\n             */\n            var dependencyList = dependencies.map(getNamePath); // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n            // emitted earlier and they will work there\n            // If set it may cause unnecessary twice rerendering\n\n            if (dependencyList.some(function (dependency) {\n              return containsNamePath(info.relatedFields, dependency);\n            })) {\n              _this.reRender();\n\n              return;\n            }\n\n            break;\n          }\n\n        default:\n          // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n          //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n          //      If `namePathList` is [['list']] (List value update), Field should be updated\n          //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n          // 2.\n          //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n          //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n          //       is not provided\n          //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n          //       else to check if value changed\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            _this.reRender();\n\n            return;\n          }\n\n          break;\n      }\n\n      if (shouldUpdate === true) {\n        _this.reRender();\n      }\n    };\n\n    _this.validateRules = function (options) {\n      var _this$props5 = _this.props,\n          _this$props5$validate = _this$props5.validateFirst,\n          validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate,\n          messageVariables = _this$props5.messageVariables;\n\n      var _ref2 = options || {},\n          triggerName = _ref2.triggerName;\n\n      var namePath = _this.getNamePath();\n\n      var filteredRules = _this.getRules();\n\n      if (triggerName) {\n        filteredRules = filteredRules.filter(function (rule) {\n          var validateTrigger = rule.validateTrigger;\n\n          if (!validateTrigger) {\n            return true;\n          }\n\n          var triggerList = toArray(validateTrigger);\n          return triggerList.includes(triggerName);\n        });\n      }\n\n      var promise = validateRules(namePath, _this.getValue(), filteredRules, options, validateFirst, messageVariables);\n      _this.dirty = true;\n      _this.validatePromise = promise;\n      _this.errors = []; // Force trigger re-render since we need sync renderProps with new meta\n\n      _this.reRender();\n\n      promise.catch(function (e) {\n        return e;\n      }).then(function () {\n        var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        if (_this.validatePromise === promise) {\n          _this.validatePromise = null;\n          _this.errors = errors;\n\n          _this.reRender();\n        }\n      });\n      return promise;\n    };\n\n    _this.isFieldValidating = function () {\n      return !!_this.validatePromise;\n    };\n\n    _this.isFieldTouched = function () {\n      return _this.touched;\n    };\n\n    _this.isFieldDirty = function () {\n      return _this.dirty;\n    };\n\n    _this.getErrors = function () {\n      return _this.errors;\n    };\n\n    _this.isListField = function () {\n      return _this.props.isListField;\n    }; // ============================= Child Component =============================\n\n\n    _this.getMeta = function () {\n      // Make error & validating in cache to save perf\n      _this.prevValidating = _this.isFieldValidating();\n      var meta = {\n        touched: _this.isFieldTouched(),\n        validating: _this.prevValidating,\n        errors: _this.errors,\n        name: _this.getNamePath()\n      };\n      return meta;\n    }; // Only return validate child node. If invalidate, will do nothing about field.\n\n\n    _this.getOnlyChild = function (children) {\n      // Support render props\n      if (typeof children === 'function') {\n        var meta = _this.getMeta();\n\n        return _objectSpread(_objectSpread({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {\n          isFunction: true\n        });\n      } // Filed element only\n\n\n      var childList = toChildrenArray(children);\n\n      if (childList.length !== 1 || !React.isValidElement(childList[0])) {\n        return {\n          child: childList,\n          isFunction: false\n        };\n      }\n\n      return {\n        child: childList[0],\n        isFunction: false\n      };\n    }; // ============================== Field Control ==============================\n\n\n    _this.getValue = function (store) {\n      var getFieldsValue = _this.props.fieldContext.getFieldsValue;\n\n      var namePath = _this.getNamePath();\n\n      return getValue(store || getFieldsValue(true), namePath);\n    };\n\n    _this.getControlled = function () {\n      var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$props6 = _this.props,\n          trigger = _this$props6.trigger,\n          validateTrigger = _this$props6.validateTrigger,\n          getValueFromEvent = _this$props6.getValueFromEvent,\n          normalize = _this$props6.normalize,\n          valuePropName = _this$props6.valuePropName,\n          getValueProps = _this$props6.getValueProps,\n          fieldContext = _this$props6.fieldContext;\n      var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n\n      var namePath = _this.getNamePath();\n\n      var getInternalHooks = fieldContext.getInternalHooks,\n          getFieldsValue = fieldContext.getFieldsValue;\n\n      var _getInternalHooks = getInternalHooks(HOOK_MARK),\n          dispatch = _getInternalHooks.dispatch;\n\n      var value = _this.getValue();\n\n      var mergedGetValueProps = getValueProps || function (val) {\n        return _defineProperty({}, valuePropName, val);\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      var originTriggerFunc = childProps[trigger];\n\n      var control = _objectSpread(_objectSpread({}, childProps), mergedGetValueProps(value)); // Add trigger\n\n\n      control[trigger] = function () {\n        // Mark as touched\n        _this.touched = true;\n        _this.dirty = true;\n        var newValue;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (getValueFromEvent) {\n          newValue = getValueFromEvent.apply(void 0, args);\n        } else {\n          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));\n        }\n\n        if (normalize) {\n          newValue = normalize(newValue, value, getFieldsValue(true));\n        }\n\n        dispatch({\n          type: 'updateValue',\n          namePath: namePath,\n          value: newValue\n        });\n\n        if (originTriggerFunc) {\n          originTriggerFunc.apply(void 0, args);\n        }\n      }; // Add validateTrigger\n\n\n      var validateTriggerList = toArray(mergedValidateTrigger || []);\n      validateTriggerList.forEach(function (triggerName) {\n        // Wrap additional function of component, so that we can get latest value from store\n        var originTrigger = control[triggerName];\n\n        control[triggerName] = function () {\n          if (originTrigger) {\n            originTrigger.apply(void 0, arguments);\n          } // Always use latest rules\n\n\n          var rules = _this.props.rules;\n\n          if (rules && rules.length) {\n            // We dispatch validate to root,\n            // since it will update related data with other field with same name\n            dispatch({\n              type: 'validateField',\n              namePath: namePath,\n              triggerName: triggerName\n            });\n          }\n        };\n      });\n      return control;\n    }; // Register on init\n\n\n    if (props.fieldContext) {\n      var getInternalHooks = props.fieldContext.getInternalHooks;\n\n      var _getInternalHooks2 = getInternalHooks(HOOK_MARK),\n          registerField = _getInternalHooks2.registerField;\n\n      _this.cancelRegisterFunc = registerField(_assertThisInitialized(_this));\n    }\n\n    return _this;\n  }\n\n  _createClass(Field, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var shouldUpdate = this.props.shouldUpdate;\n      this.mounted = true; // One more render for component in case fields not ready\n\n      if (shouldUpdate === true) {\n        this.reRender();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelRegister();\n      this.mounted = false;\n    }\n  }, {\n    key: \"reRender\",\n    value: function reRender() {\n      if (!this.mounted) return;\n      this.forceUpdate();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var resetCount = this.state.resetCount;\n      var children = this.props.children;\n\n      var _this$getOnlyChild = this.getOnlyChild(children),\n          child = _this$getOnlyChild.child,\n          isFunction = _this$getOnlyChild.isFunction; // Not need to `cloneElement` since user can handle this in render function self\n\n\n      var returnChildNode;\n\n      if (isFunction) {\n        returnChildNode = child;\n      } else if (React.isValidElement(child)) {\n        returnChildNode = React.cloneElement(child, this.getControlled(child.props));\n      } else {\n        warning(!child, '`children` of Field is not validate ReactElement.');\n        returnChildNode = child;\n      }\n\n      return React.createElement(React.Fragment, {\n        key: resetCount\n      }, returnChildNode);\n    }\n  }]);\n\n  return Field;\n}(React.Component);\n\nField.contextType = FieldContext;\nField.defaultProps = {\n  trigger: 'onChange',\n  valuePropName: 'value'\n};\n\nfunction WrapperField(_ref4) {\n  var name = _ref4.name,\n      restProps = _objectWithoutProperties(_ref4, [\"name\"]);\n\n  var fieldContext = React.useContext(FieldContext);\n  var namePath = name !== undefined ? getNamePath(name) : undefined;\n  var key = 'keep';\n\n  if (!restProps.isListField) {\n    key = \"_\".concat((namePath || []).join('_'));\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    warning(restProps.preserve !== false || !restProps.isListField, '`preserve` should not apply on Form.List fields.');\n  }\n\n  return React.createElement(Field, Object.assign({\n    key: key,\n    name: namePath\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\n\nexport default WrapperField;"]},"metadata":{},"sourceType":"module"}